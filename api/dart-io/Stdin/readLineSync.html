<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-core/String-class.html">
    String
   </a>
  </span>
  <span class="name ">
   readLineSync
  </span>
  (
  <wbr>
  {
  <span class="parameter" id="readLineSync-param-encoding">
   <span class="type-annotation">
    <a class="" href="dart-convert/Encoding-class.html">
     Encoding
    </a>
   </span>
   <span class="parameter-name">
    encoding
   </span>
   :
   <span class="default-value">
    SYSTEM_ENCODING
   </span>
  </span>
  ,
  <span class="parameter" id="readLineSync-param-retainNewlines">
   <span class="type-annotation">
    <a class="" href="dart-core/bool-class.html">
     bool
    </a>
   </span>
   <span class="parameter-name">
    retainNewlines
   </span>
   :
   <span class="default-value">
    false
   </span>
  </span>
  })
 </section>
 <section class="desc markdown">
  <p>
   Synchronously read a line from stdin. This call will block until a full
line is available.
  </p>
  <p>
   The argument
   <code>
    encoding
   </code>
   can be used to changed how the input should be
decoded. Default is
   <a class="" href="dart-io/SYSTEM_ENCODING.html">
    SYSTEM_ENCODING
   </a>
   .
  </p>
  <p>
   If
   <code>
    retainNewlines
   </code>
   is
   <code>
    false
   </code>
   , the returned String will not contain the
final newline. If
   <code>
    true
   </code>
   , the returned String will contain the line
terminator. Default is
   <code>
    false
   </code>
   .
  </p>
  <p>
   If end-of-file is reached after any bytes have been read from stdin,
that data is returned.
Returns
   <code>
    null
   </code>
   if no bytes preceeded the end of input.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    String readLineSync({Encoding encoding: SYSTEM_ENCODING,
                     bool retainNewlines: false}) {
  const CR = 13;
  const LF = 10;
  final List line = [];
  // On Windows, if lineMode is disabled, only CR is received.
  bool crIsNewline = Platform.isWindows &amp;&amp;
      (stdioType(stdin) == StdioType.TERMINAL) &amp;&amp;
      !lineMode;
  if (retainNewlines) {
    int byte;
    do {
      byte = readByteSync();
      if (byte &lt; 0) {
        break;
      }
      line.add(byte);
    } while (byte != LF &amp;&amp; !(byte == CR &amp;&amp; crIsNewline));
    if (line.isEmpty) {
      return null;
    }
  } else if (crIsNewline) {
    // CR and LF are both line terminators, neither is retained.
    while (true) {
      int byte = readByteSync();
      if (byte &lt; 0) {
        if (line.isEmpty) return null;
        break;
      }
      if (byte == LF || byte == CR) break;
      line.add(byte);
    }
  } else {
    // Case having to hande CR LF as a single unretained line terminator.
    outer: while (true) {
      int byte = readByteSync();
      if (byte == LF) break;
      if (byte == CR) {
        do {
          byte = readByteSync();
          if (byte == LF) break outer;

          line.add(CR);
        } while (byte == CR);
        // Fall through and handle non-CR character.
      }
      if (byte &lt; 0) {
        if (line.isEmpty) return null;
        break;
      }
      line.add(byte);
    }
  }
  return encoding.decode(line);
}
   </code>
  </pre>
 </section>
</div>
