<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   &lt;
   <a class="" href="dart-io/RawSecureSocket-class.html">
    RawSecureSocket
   </a>
   &gt;
  </span>
  <span class="name ">
   connect
  </span>
  (
  <wbr>
  <span class="parameter" id="connect-param-host">
   <span class="parameter-name">
    host
   </span>
  </span>
  ,
  <span class="parameter" id="connect-param-port">
   <span class="type-annotation">
    <a class="" href="dart-core/int-class.html">
     int
    </a>
   </span>
   <span class="parameter-name">
    port
   </span>
  </span>
  , {
  <span class="parameter" id="connect-param-sendClientCertificate">
   <span class="type-annotation">
    <a class="" href="dart-core/bool-class.html">
     bool
    </a>
   </span>
   <span class="parameter-name">
    sendClientCertificate
   </span>
   :
   <span class="default-value">
    false
   </span>
  </span>
  ,
  <span class="parameter" id="connect-param-certificateName">
   <span class="type-annotation">
    <a class="" href="dart-core/String-class.html">
     String
    </a>
   </span>
   <span class="parameter-name">
    certificateName
   </span>
  </span>
  ,
  <span class="parameter" id="connect-param-onBadCertificate">
   <span class="type-annotation">
    bool
   </span>
   <span class="parameter-name">
    onBadCertificate
   </span>
   (
   <span class="parameter" id="onBadCertificate-param-certificate">
    <span class="type-annotation">
     <a class="" href="dart-io/X509Certificate-class.html">
      X509Certificate
     </a>
    </span>
    <span class="parameter-name">
     certificate
    </span>
   </span>
   )
  </span>
  ,
  <span class="parameter" id="connect-param-supportedProtocols">
   <span class="type-annotation">
    <a class="" href="dart-core/List-class.html">
     List
    </a>
    &lt;
    <a class="" href="dart-core/String-class.html">
     String
    </a>
    &gt;
   </span>
   <span class="parameter-name">
    supportedProtocols
   </span>
  </span>
  })
 </section>
 <section class="desc markdown">
  <p>
   Constructs a new secure client socket and connect it to the given
host on the given port. The returned Future is completed with the
RawSecureSocket when it is connected and ready for subscription.
  </p>
  <p>
   The certificate provided by the server is checked using the certificate
database provided in
   <a class="" href="dart-io/SecureSocket/initialize.html">
    SecureSocket.initialize
   </a>
   , and/or the default built-in
root certificates. If
   <code>
    sendClientCertificate
   </code>
   is
set to true, the socket will send a client certificate if one is
requested by the server. If
   <code>
    certificateName
   </code>
   is the nickname of
a certificate in the certificate database, that certificate will be sent.
If
   <code>
    certificateName
   </code>
   is null, which is the usual use case, an
appropriate certificate will be searched for in the database and
sent automatically, based on what the server says it will accept.
  </p>
  <p>
   <code>
    onBadCertificate
   </code>
   is an optional handler for unverifiable certificates.
The handler receives the
   <a class="" href="dart-io/X509Certificate-class.html">
    X509Certificate
   </a>
   , and can inspect it and
decide (or let the user decide) whether to accept
the connection or not.  The handler should return true
to continue the
   <a class="" href="dart-io/RawSecureSocket-class.html">
    RawSecureSocket
   </a>
   connection.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    static Future&lt;RawSecureSocket&gt; connect(
    host,
    int port,
    {bool sendClientCertificate: false,
     String certificateName,
     bool onBadCertificate(X509Certificate certificate),
     List&lt;String&gt; supportedProtocols}) {
  _RawSecureSocket._verifyFields(
      host,
      port,
      certificateName,
      false,
      false,
      false,
      sendClientCertificate,
      onBadCertificate);
  return RawSocket.connect(host, port)
      .then((socket) {
        return secure(socket,
                      sendClientCertificate: sendClientCertificate,
                      certificateName: certificateName,
                      onBadCertificate: onBadCertificate,
                      supportedProtocols: supportedProtocols);
      });
}
   </code>
  </pre>
 </section>
</div>
