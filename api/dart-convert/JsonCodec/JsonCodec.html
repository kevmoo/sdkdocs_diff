<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  const
  <span class="name ">
   JsonCodec
  </span>
  (
  <wbr>
  {
  <span class="parameter" id="-param-reviver">
   <span class="type-annotation">
    dynamic
   </span>
   <span class="parameter-name">
    reviver
   </span>
   (
   <span class="parameter" id="reviver-param-key">
    <span class="parameter-name">
     key
    </span>
   </span>
   ,
   <span class="parameter" id="reviver-param-value">
    <span class="parameter-name">
     value
    </span>
   </span>
   )
  </span>
  ,
  <span class="parameter" id="-param-toEncodable">
   <span class="type-annotation">
    dynamic
   </span>
   <span class="parameter-name">
    toEncodable
   </span>
   (
   <span class="parameter" id="toEncodable-param-object">
    <span class="parameter-name">
     object
    </span>
   </span>
   )
  </span>
  })
 </section>
 <section class="desc markdown">
  <p>
   Creates a
   <code>
    JsonCodec
   </code>
   with the given reviver and encoding function.
  </p>
  <p>
   The
   <code>
    reviver
   </code>
   function is called during decoding. It is invoked
once for each object or list property that has been parsed.
The
   <code>
    key
   </code>
   argument is either the
integer list index for a list property, the string map key for object
properties, or
   <code>
    null
   </code>
   for the final result.
  </p>
  <p>
   If
   <code>
    reviver
   </code>
   is omitted, it defaults to returning the value argument.
  </p>
  <p>
   The
   <code>
    toEncodable
   </code>
   function is used during encoding. It is invoked for
values that are not directly encodable to a JSON1toE
string (a value that is not a number, boolean, string, null, list or a map
with string keys). The function must return an object that is directly
encodable. The elements of a returned list and values of a returned map
do not need be directly encodable, and if they aren&#39;t,
   <code>
    toEncodable
   </code>
   will
be used on them as well.
Please notice that it is possible to cause an infinite recursive
regress in this way, by effectively creating an infinite data structure
through repeated call to
   <code>
    toEncodable
   </code>
   .
  </p>
  <p>
   If
   <code>
    toEncodable
   </code>
   is omitted, it defaults to a function that returns the
result of calling
   <code>
    .toJson()
   </code>
   on the unencodable object.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    const JsonCodec({reviver(var key, var value), toEncodable(var object)})
    : _reviver = reviver,
      _toEncodable = toEncodable;
   </code>
  </pre>
 </section>
</div>
