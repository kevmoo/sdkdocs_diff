<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   dynamic
  </span>
  <span class="name ">
   wrap_jso
  </span>
  (
  <wbr>
  <span class="parameter" id="wrap_jso-param-jsObject">
   <span class="parameter-name">
    jsObject
   </span>
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Create Dart class that maps to the JS Type, add the JsObject as an expando
on the Dart class and return the created Dart class.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    wrap_jso(jsObject) {
  try {
    if (jsObject is! js.JsObject || jsObject == null) {
      // JS Interop converted the object to a Dart class e.g., Uint8ClampedList.
      // or it&#39;s a simple type.
      return jsObject;
    }

    var wrapper = js.getDartHtmlWrapperFor(jsObject);
    // if we have a wrapper return the Dart instance.
    if (wrapper != null) {
      if (wrapper.runtimeType == HtmlElement &amp;&amp; !wrapper._isBadUpgrade) {
        // We&#39;re a Dart instance but we need to upgrade.
        var customElementClass = _getCustomElementType(wrapper);
        if (customElementClass != null) {
          var dartClass_instance;
          try {
            dartClass_instance = _blink.Blink_Utils.constructElement(customElementClass, jsObject);
          } finally {
            dartClass_instance.blink_jsObject = jsObject;
            jsObject[&#39;dart_class&#39;] = dartClass_instance;
            js.setDartHtmlWrapperFor(jsObject, dartClass_instance);
            return dartClass_instance;
          }
        }
      }

      return wrapper;
    }

    if (jsObject is js.JsArray) {
      var wrappingList = new _DartHtmlWrappingList(jsObject);
      js.setDartHtmlWrapperFor(jsObject, wrappingList);
      return wrappingList;
    }

    // Try the most general type conversions on it.
    // TODO(alanknight): We may be able to do better. This maintains identity,
    // which is useful, but expensive. And if we nest something that only
    // this conversion handles, how does that work? e.g. a list of maps of elements.
    var converted = convertNativeToDart_SerializedScriptValue(jsObject);
    if (!identical(converted, jsObject)) {
      return converted;
    }

    var constructor = js.JsNative.getProperty(jsObject, &#39;constructor&#39;);
    if (constructor == null) {
      // Perfectly valid case for JavaScript objects where __proto__ has
      // intentionally been set to null.
      js.setDartHtmlWrapperFor(jsObject, jsObject);
      return jsObject;
    }
    var jsTypeName = js.JsNative.getProperty(constructor, &#39;name&#39;);
    if (jsTypeName is! String || jsTypeName.length == 0) {
      // Not an html type.
      js.setDartHtmlWrapperFor(jsObject, jsObject);
      return jsObject;
    }

    var dartClass_instance;
    if (jsObject.hasProperty(&#39;dart_class&#39;)) {
      // Got a dart_class (it&#39;s a custom element) use it it&#39;s already set up
      // make sure it&#39;s upgraded.
      dartClass_instance = _upgradeHtmlElement(jsObject[&#39;dart_class&#39;]);
    } else {
      var customElementClass = null;
      var extendsTag = &#34;&#34;;
      var custom = _getCustomElement(jsObject);
      if (custom != null) {
        customElementClass = custom[&#39;type&#39;];
        extendsTag = custom[&#39;extends&#39;];
      }
      // Custom Element to upgrade.
      if (jsTypeName == &#39;HTMLElement&#39; &amp;&amp; customElementClass != null &amp;&amp; extendsTag == &#34;&#34;) {
        try {
          dartClass_instance = _blink.Blink_Utils.constructElement(customElementClass, jsObject);
        } finally {
          dartClass_instance.blink_jsObject = jsObject;
          jsObject[&#39;dart_class&#39;] = dartClass_instance;
          js.setDartHtmlWrapperFor(jsObject, dartClass_instance);
       }
      } else {
        // TODO(terry): Verify with jakemacd that this is right?
        // If we every get an auto-binding we&#39;re matching previous non-JS Interop
        // did to return a TemplateElement.
        if (jsTypeName == &#39;auto-binding&#39;) {
          jsTypeName = &#34;HTMLTemplateElement&#34;;
        }

        var func = getHtmlCreateFunction(jsTypeName);
        if (func == null) {
          // One last ditch effort could be a JS custom element.
          if (jsObject.toString() == &#34;[object HTMLElement]&#34;) {
            func = getHtmlCreateFunction(&#34;HTMLElement&#34;);
          }
        }
        if (func != null) {
          dartClass_instance = func();
          dartClass_instance.blink_jsObject = jsObject;
          js.setDartHtmlWrapperFor(jsObject, dartClass_instance);
        }
      }
    }
    // TODO(jacobr): cache that this is not a dart:html JS class.
    return dartClass_instance;
  } catch(e, stacktrace){
    if (__interop_checks) {
      if (e is DebugAssertException)
        window.console.log(&#34;${e.message}\n ${stacktrace}&#34;);
      else
        window.console.log(&#34;${stacktrace}&#34;);
    }
  }

  return null;
}
   </code>
  </pre>
 </section>
</div>
