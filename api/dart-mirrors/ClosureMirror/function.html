<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section id="getter">
  <section class="multi-line-signature">
   <span class="returntype">
    <a class="" href="dart-mirrors/MethodMirror-class.html">
     MethodMirror
    </a>
   </span>
   <span class="name ">
    function
   </span>
  </section>
  <section class="desc markdown">
   <p>
    A mirror on the function associated with this closure.
   </p>
   <p>
    The function associated with an implicit closure of a function is that
function.
   </p>
   <p>
    The function associated with an instance of a class that has a
    <code>
     call
    </code>
    method is that
    <code>
     call
    </code>
    method.
   </p>
   <p>
    A Dart implementation might choose to create a class for each closure
expression, in which case
    <code>
     function
    </code>
    would be the same as
    <code>
     type.declarations[#call]
    </code>
    . But the Dart language model does not require
this. A more typical implementation involves a single closure class for
each type signature, where the call method dispatches to a function held
in the closure rather the call method
directly implementing the closure body. So one cannot rely on closures from
distinct closure expressions having distinct classes (
    <code>
     type
    </code>
    ), but one
can rely on them having distinct functions (
    <code>
     function
    </code>
    ).
   </p>
  </section>
 </section>
</div>
