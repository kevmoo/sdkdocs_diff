<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-core/Uri-class.html">
    Uri
   </a>
  </span>
  <span class="name ">
   resolveUri
  </span>
  (
  <wbr>
  <span class="parameter" id="resolveUri-param-reference">
   <span class="type-annotation">
    <a class="" href="dart-core/Uri-class.html">
     Uri
    </a>
   </span>
   <span class="parameter-name">
    reference
   </span>
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Resolve
   <code>
    reference
   </code>
   as an URI relative to
   <code>
    this
   </code>
   .
  </p>
  <p>
   Returns the resolved URI.
  </p>
  <p>
   The algorithm &#34;Transform Reference&#34; for resolving a reference is
described in
   <a href="http://tools.ietf.org/html/rfc3986#section-5" title="RFC-1123">
    RFC-3986 Section 5
   </a>
   .
  </p>
  <p>
   Updated to handle the case where the base URI is just a relative path -
that is: when it has no scheme or authority and the path does not start
with a slash.
In that case, the paths are combined without removing leading &#34;..&#34;, and
an empty path is not converted to &#34;/&#34;.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    Uri resolveUri(Uri reference) {
  // From RFC 3986.
  String targetScheme;
  String targetUserInfo = &#34;&#34;;
  String targetHost;
  int targetPort;
  String targetPath;
  String targetQuery;
  if (reference.scheme.isNotEmpty) {
    targetScheme = reference.scheme;
    if (reference.hasAuthority) {
      targetUserInfo = reference.userInfo;
      targetHost = reference.host;
      targetPort = reference.hasPort ? reference.port : null;
    }
    targetPath = _removeDotSegments(reference.path);
    if (reference.hasQuery) {
      targetQuery = reference.query;
    }
  } else {
    targetScheme = this.scheme;
    if (reference.hasAuthority) {
      targetUserInfo = reference.userInfo;
      targetHost = reference.host;
      targetPort = _makePort(reference.hasPort ? reference.port : null,
                             targetScheme);
      targetPath = _removeDotSegments(reference.path);
      if (reference.hasQuery) targetQuery = reference.query;
    } else {
      targetUserInfo = this._userInfo;
      targetHost = this._host;
      targetPort = this._port;
      if (reference.path == &#34;&#34;) {
        targetPath = this._path;
        if (reference.hasQuery) {
          targetQuery = reference.query;
        } else {
          targetQuery = this._query;
        }
      } else {
        if (reference.hasAbsolutePath) {
          targetPath = _removeDotSegments(reference.path);
        } else {
          // This is the RFC 3986 behavior for merging.
          if (this.hasEmptyPath) {
            if (!this.hasScheme &amp;&amp; !this.hasAuthority) {
              // Keep the path relative if no scheme or authority.
              targetPath = reference.path;
            } else {
              // Add path normalization on top of RFC algorithm.
              targetPath = _removeDotSegments(&#34;/&#34; + reference.path);
            }
          } else {
            var mergedPath = _mergePaths(this._path, reference.path);
            if (this.hasScheme || this.hasAuthority || this.hasAbsolutePath) {
              targetPath = _removeDotSegments(mergedPath);
            } else {
              // Non-RFC 3986 beavior. If both base and reference are relative
              // path, allow the merged path to start with &#34;..&#34;.
              // The RFC only specifies the case where the base has a scheme.
              targetPath = _normalizeRelativePath(mergedPath);
            }
          }
        }
        if (reference.hasQuery) targetQuery = reference.query;
      }
    }
  }
  String fragment = reference.hasFragment ? reference.fragment : null;
  return new Uri._internal(targetScheme,
                           targetUserInfo,
                           targetHost,
                           targetPort,
                           targetPath,
                           targetQuery,
                           fragment);
}
   </code>
  </pre>
 </section>
</div>
