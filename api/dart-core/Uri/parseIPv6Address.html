<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-core/List-class.html">
    List
   </a>
   &lt;
   <a class="" href="dart-core/int-class.html">
    int
   </a>
   &gt;
  </span>
  <span class="name ">
   parseIPv6Address
  </span>
  (
  <wbr>
  <span class="parameter" id="parseIPv6Address-param-host">
   <span class="type-annotation">
    <a class="" href="dart-core/String-class.html">
     String
    </a>
   </span>
   <span class="parameter-name">
    host
   </span>
  </span>
  , [
  <span class="parameter" id="parseIPv6Address-param-start">
   <span class="type-annotation">
    <a class="" href="dart-core/int-class.html">
     int
    </a>
   </span>
   <span class="parameter-name">
    start
   </span>
   =
   <span class="default-value">
    0
   </span>
  </span>
  ,
  <span class="parameter" id="parseIPv6Address-param-end">
   <span class="type-annotation">
    <a class="" href="dart-core/int-class.html">
     int
    </a>
   </span>
   <span class="parameter-name">
    end
   </span>
  </span>
  ])
 </section>
 <section class="desc markdown">
  <p>
   Parse the
   <code>
    host
   </code>
   as an IP version 6 (IPv6) address, returning the address
as a list of 16 bytes in network byte order (big endian).
  </p>
  <p>
   Throws a
   <a class="" href="dart-core/FormatException-class.html">
    FormatException
   </a>
   if
   <code>
    host
   </code>
   is not a valid IPv6 address
representation.
  </p>
  <p>
   Acts on the substring from
   <code>
    start
   </code>
   to
   <code>
    end
   </code>
   . If
   <code>
    end
   </code>
   is omitted, it
defaults ot the end of the string.
  </p>
  <p>
   Some examples of IPv6 addresses:
 * ::1
 * FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
 * 3ffe:2a00:100:7031::1
 * ::FFFF:129.144.52.38
 * 2010:836B:4179::836B:4179
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    static List&lt;int&gt; parseIPv6Address(String host, [int start = 0, int end]) {
  if (end == null) end = host.length;
  // An IPv6 address consists of exactly 8 parts of 1-4 hex digits, seperated
  // by `:`&#39;s, with the following exceptions:
  //
  //  - One (and only one) wildcard (`::`) may be present, representing a fill
  //    of 0&#39;s. The IPv6 `::` is thus 16 bytes of `0`.
  //  - The last two parts may be replaced by an IPv4 address.
  void error(String msg, [position]) {
    throw new FormatException(&#39;Illegal IPv6 address, $msg&#39;, host, position);
  }
  int parseHex(int start, int end) {
    if (end - start &gt; 4) {
      error(&#39;an IPv6 part can only contain a maximum of 4 hex digits&#39;, start);
    }
    int value = int.parse(host.substring(start, end), radix: 16);
    if (value &lt; 0 || value &gt; (1 &lt;&lt; 16) - 1) {
      error(&#39;each part must be in the range of `0x0..0xFFFF`&#39;, start);
    }
    return value;
  }
  if (host.length &lt; 2) error(&#39;address is too short&#39;);
  List&lt;int&gt; parts = [];
  bool wildcardSeen = false;
  int partStart = start;
  // Parse all parts, except a potential last one.
  for (int i = start; i &lt; end; i++) {
    if (host.codeUnitAt(i) == _COLON) {
      if (i == start) {
        // If we see a `:` in the beginning, expect wildcard.
        i++;
        if (host.codeUnitAt(i) != _COLON) {
          error(&#39;invalid start colon.&#39;, i);
        }
        partStart = i;
      }
      if (i == partStart) {
        // Wildcard. We only allow one.
        if (wildcardSeen) {
          error(&#39;only one wildcard `::` is allowed&#39;, i);
        }
        wildcardSeen = true;
        parts.add(-1);
      } else {
        // Found a single colon. Parse [partStart..i] as a hex entry.
        parts.add(parseHex(partStart, i));
      }
      partStart = i + 1;
    }
  }
  if (parts.length == 0) error(&#39;too few parts&#39;);
  bool atEnd = (partStart == end);
  bool isLastWildcard = (parts.last == -1);
  if (atEnd &amp;&amp; !isLastWildcard) {
    error(&#39;expected a part after last `:`&#39;, end);
  }
  if (!atEnd) {
    try {
      parts.add(parseHex(partStart, end));
    } catch (e) {
      // Failed to parse the last chunk as hex. Try IPv4.
      try {
        List&lt;int&gt; last = parseIPv4Address(host.substring(partStart, end));
        parts.add(last[0] &lt;&lt; 8 | last[1]);
        parts.add(last[2] &lt;&lt; 8 | last[3]);
      } catch (e) {
        error(&#39;invalid end of IPv6 address.&#39;, partStart);
      }
    }
  }
  if (wildcardSeen) {
    if (parts.length &gt; 7) {
      error(&#39;an address with a wildcard must have less than 7 parts&#39;);
    }
  } else if (parts.length != 8) {
    error(&#39;an address without a wildcard must contain exactly 8 parts&#39;);
  }
  // TODO(ajohnsen): Consider using Uint8List.
  List bytes = new List&lt;int&gt;(16);
  for (int i = 0, index = 0; i &lt; parts.length; i++) {
    int value = parts[i];
    if (value == -1) {
      int wildCardLength = 9 - parts.length;
      for (int j = 0; j &lt; wildCardLength; j++) {
        bytes[index] = 0;
        bytes[index + 1] = 0;
        index += 2;
      }
    } else {
      bytes[index] = value &gt;&gt; 8;
      bytes[index + 1] = value &amp; 0xff;
      index += 2;
    }
  }
  return bytes;
}
   </code>
  </pre>
 </section>
</div>
