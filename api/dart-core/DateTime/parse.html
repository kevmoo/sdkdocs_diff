<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-core/DateTime-class.html">
    DateTime
   </a>
  </span>
  <span class="name ">
   parse
  </span>
  (
  <wbr>
  <span class="parameter" id="parse-param-formattedString">
   <span class="type-annotation">
    <a class="" href="dart-core/String-class.html">
     String
    </a>
   </span>
   <span class="parameter-name">
    formattedString
   </span>
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Constructs a new
   <a class="" href="dart-core/DateTime-class.html">
    DateTime
   </a>
   instance based on
   <code>
    formattedString
   </code>
   .
  </p>
  <p>
   Throws a
   <a class="" href="dart-core/FormatException-class.html">
    FormatException
   </a>
   if the input cannot be parsed.
  </p>
  <p>
   The function parses a subset of ISO 8601
which includes the subset accepted by RFC 3339.
  </p>
  <p>
   The accepted inputs are currently:
  </p>
  <ul>
   <li>
    <p>
     A date: A signed four-to-six digit year, two digit month and
  two digit day, optionally separated by
     <code>
      -
     </code>
     characters.
  Examples: &#34;19700101&#34;, &#34;-0004-12-24&#34;, &#34;81030-04-01&#34;.
    </p>
   </li>
   <li>
    <p>
     An optional time part, separated from the date by either
     <code>
      T
     </code>
     or a space.
  The time part is a two digit hour,
  then optionally a two digit minutes value,
  then optionally a two digit seconds value, and
  then optionally a &#39;.&#39; followed by a one-to-six digit second fraction.
  The minuts and seconds may be separated from the previous parts by a &#39;:&#39;.
  Examples: &#34;12&#34;, &#34;12:30:24.124&#34;, &#34;123010.50&#34;.
    </p>
   </li>
   <li>
    <p>
     An optional time-zone offset part,
  possibly separated from the previous by a space.
  The time zone is either &#39;z&#39; or &#39;Z&#39;, or it is a signed two digit hour
  part and an optional two digit minute part. The sign must be either
  &#34;+&#34; or &#34;-&#34;, and can not be omitted.
  The minutes may be separted from the hours by a &#39;:&#39;.
  Examples: &#34;Z&#34;, &#34;-10&#34;, &#34;01:30&#34;, &#34;1130&#34;.
    </p>
   </li>
  </ul>
  <p>
   This includes the output of both
   <a class="" href="dart-core/DateTime/toString.html">
    toString
   </a>
   and
   <a class="" href="dart-core/DateTime/toIso8601String.html">
    toIso8601String
   </a>
   , which
will be parsed back into a
   <code>
    DateTime
   </code>
   object with the same time as the
original.
  </p>
  <p>
   The result is always in either local time or UTC.
If a time zone offset other than UTC is specified,
the time is converted to the equivalent UTC time.
  </p>
  <p>
   Examples of accepted strings:
  </p>
  <ul>
   <li>
    <code>
     &#34;2012-02-27 13:27:00&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;2012-02-27 13:27:00.123456z&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;20120227 13:27:00&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;20120227T132700&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;20120227&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;+20120227&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;2012-02-27T14Z&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;2012-02-27T14+00:00&#34;
    </code>
   </li>
   <li>
    <code>
     &#34;-123450101 00:00:00 Z&#34;
    </code>
    : in the year -12345.
   </li>
   <li>
    <code>
     &#34;2002-02-27T14:00:00-0500&#34;
    </code>
    : Same as
    <code>
     &#34;2002-02-27T19:00:00Z&#34;
    </code>
   </li>
  </ul>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    // TODO(lrn): restrict incorrect values like  2003-02-29T50:70:80.
// Or not, that may be a breaking change.
static DateTime parse(String formattedString) {
  /*
   * date ::= yeardate time_opt timezone_opt
   * yeardate ::= year colon_opt month colon_opt day
   * year ::= sign_opt digit{4,6}
   * colon_opt :: &lt;empty&gt; | &#39;:&#39;
   * sign ::= &#39;+&#39; | &#39;-&#39;
   * sign_opt ::=  &lt;empty&gt; | sign
   * month ::= digit{2}
   * day ::= digit{2}
   * time_opt ::= &lt;empty&gt; | (&#39; &#39; | &#39;T&#39;) hour minutes_opt
   * minutes_opt ::= &lt;empty&gt; | colon_opt digit{2} seconds_opt
   * seconds_opt ::= &lt;empty&gt; | colon_opt digit{2} millis_opt
   * millis_opt ::= &lt;empty&gt; | &#39;.&#39; digit{1,6}
   * timezone_opt ::= &lt;empty&gt; | space_opt timezone
   * space_opt :: &#39; &#39; | &lt;empty&gt;
   * timezone ::= &#39;z&#39; | &#39;Z&#39; | sign digit{2} timezonemins_opt
   * timezonemins_opt ::= &lt;empty&gt; | colon_opt digit{2}
   */
  final RegExp re = new RegExp(
      r&#39;^([+-]?\d{4,6})-?(\d\d)-?(\d\d)&#39;  // Day part.
      r&#39;(?:[ T](\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d{1,6}))?)?)?&#39; // Time part.
      r&#39;( ?[zZ]| ?([-+])(\d\d)(?::?(\d\d))?)?)?$&#39;); // Timezone part.

  Match match = re.firstMatch(formattedString);
  if (match != null) {
    int parseIntOrZero(String matched) {
      if (matched == null) return 0;
      return int.parse(matched);
    }

    // Parses fractional second digits of &#39;.(\d{1,6})&#39; into milliseconds.
    // Uses first three digits (assumed to be zero if not there), and
    // rounds up if fourth digit is 5 or greater.
    // Should be equivalent to `(double.parse(&#34;.$matchd&#34;)*1000).round()`.
    int parseMilliseconds(String matched) {
      if (matched == null) return 0;
      int length = matched.length;
      assert(length &gt;= 1);
      assert(length &lt;= 6);

      int result = (matched.codeUnitAt(0) ^ 0x30);
      if (length &lt;= 3) {
        int i = 1;
        while (i &lt; length) {
          result *= 10;
          result += matched.codeUnitAt(i) ^ 0x30;
          i++;
        }
        while (i &lt; 3) {
          result *= 10;
          i++;
        }
        return result;
      }
      // Parse the prefix from 0..3 without creating a new substring.
      result = result * 10 + (matched.codeUnitAt(1) ^ 0x30);
      result = result * 10 + (matched.codeUnitAt(2) ^ 0x30);
      if (matched.codeUnitAt(3) &gt;= 0x35) {
        result += 1;
      }
      return result;
    }

    int years = int.parse(match[1]);
    int month = int.parse(match[2]);
    int day = int.parse(match[3]);
    int hour = parseIntOrZero(match[4]);
    int minute = parseIntOrZero(match[5]);
    int second = parseIntOrZero(match[6]);
    bool addOneMillisecond = false;
    int millisecond = parseMilliseconds(match[7]);
    if (millisecond == 1000) {
      addOneMillisecond = true;
      millisecond = 999;
    }
    bool isUtc = false;
    if (match[8] != null) {  // timezone part
      isUtc = true;
      if (match[9] != null) {
        // timezone other than &#39;Z&#39; and &#39;z&#39;.
        int sign = (match[9] == &#39;-&#39;) ? -1 : 1;
        int hourDifference = int.parse(match[10]);
        int minuteDifference = parseIntOrZero(match[11]);
        minuteDifference += 60 * hourDifference;
        minute -= sign * minuteDifference;
      }
    }
    int millisecondsSinceEpoch = _brokenDownDateToMillisecondsSinceEpoch(
        years, month, day, hour, minute, second, millisecond, isUtc);
    if (millisecondsSinceEpoch == null) {
      throw new FormatException(&#34;Time out of range&#34;, formattedString);
    }
    if (addOneMillisecond) millisecondsSinceEpoch++;
    return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,
                                                   isUtc: isUtc);
  } else {
    throw new FormatException(&#34;Invalid date format&#34;, formattedString);
  }
}
   </code>
  </pre>
 </section>
</div>
