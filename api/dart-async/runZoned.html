<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   dynamic
  </span>
  <span class="name ">
   runZoned
  </span>
  (
  <wbr>
  <span class="parameter" id="runZoned-param-body">
   <span class="type-annotation">
    dynamic
   </span>
   <span class="parameter-name">
    body
   </span>
   ()
  </span>
  , {
  <span class="parameter" id="runZoned-param-zoneValues">
   <span class="parameter-name">
    zoneValues
   </span>
  </span>
  ,
  <span class="parameter" id="runZoned-param-zoneSpecification">
   <span class="type-annotation">
    <a class="" href="dart-async/ZoneSpecification-class.html">
     ZoneSpecification
    </a>
   </span>
   <span class="parameter-name">
    zoneSpecification
   </span>
  </span>
  ,
  <span class="parameter" id="runZoned-param-onError">
   <span class="type-annotation">
    <a class="" href="dart-core/Function-class.html">
     Function
    </a>
   </span>
   <span class="parameter-name">
    onError
   </span>
  </span>
  })
 </section>
 <section class="desc markdown">
  <p>
   Runs
   <code>
    body
   </code>
   in its own zone.
  </p>
  <p>
   If
   <code>
    onError
   </code>
   is non-null the zone is considered an error zone. All uncaught
errors, synchronous or asynchronous, in the zone are caught and handled
by the callback.
  </p>
  <p>
   Errors may never cross error-zone boundaries. This is intuitive for leaving
a zone, but it also applies for errors that would enter an error-zone.
Errors that try to cross error-zone boundaries are considered uncaught.
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    var future = new Future.value(499);
runZoned(() {
  future = future.then((_) { throw &#34;error in first error-zone&#34;; });
  runZoned(() {
    future = future.catchError((e) { print(&#34;Never reached!&#34;); });
  }, onError: (e) { print(&#34;unused error handler&#34;); });
}, onError: (e) { print(&#34;catches error of first error-zone.&#34;); });
   </code>
  </pre>
  <p>
   Example:
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    runZoned(() {
  new Future(() { throw &#34;asynchronous error&#34;; });
}, onError: print);  // Will print &#34;asynchronous error&#34;.
   </code>
  </pre>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    dynamic runZoned(body(),
                 { Map zoneValues,
                   ZoneSpecification zoneSpecification,
                   Function onError }) {
  HandleUncaughtErrorHandler errorHandler;
  if (onError != null) {
    errorHandler = (Zone self, ZoneDelegate parent, Zone zone,
                    error, StackTrace stackTrace) {
      try {
        if (onError is ZoneBinaryCallback) {
          return self.parent.runBinary(onError, error, stackTrace);
        }
        return self.parent.runUnary(onError, error);
      } catch(e, s) {
        if (identical(e, error)) {
          return parent.handleUncaughtError(zone, error, stackTrace);
        } else {
          return parent.handleUncaughtError(zone, e, s);
        }
      }
    };
  }
  if (zoneSpecification == null) {
    zoneSpecification =
        new ZoneSpecification(handleUncaughtError: errorHandler);
  } else if (errorHandler != null) {
    zoneSpecification =
        new ZoneSpecification.from(zoneSpecification,
                                   handleUncaughtError: errorHandler);
  }
  Zone zone = Zone.current.fork(specification: zoneSpecification,
                                zoneValues: zoneValues);
  if (onError != null) {
    return zone.runGuarded(body);
  } else {
    return zone.run(body);
  }
}
   </code>
  </pre>
 </section>
</div>
