<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  const
  <span class="name ">
   StreamTransformer
  </span>
  (
  <wbr>
  <span class="parameter" id="-param-transformer">
   <span class="type-annotation">
    StreamSubscription
   </span>
   <span class="parameter-name">
    transformer
   </span>
   (
   <span class="parameter" id="transformer-param-stream">
    <span class="type-annotation">
     <a class="" href="dart-async/Stream-class.html">
      Stream
     </a>
     &lt;S&gt;
    </span>
    <span class="parameter-name">
     stream
    </span>
   </span>
   ,
   <span class="parameter" id="transformer-param-cancelOnError">
    <span class="type-annotation">
     <a class="" href="dart-core/bool-class.html">
      bool
     </a>
    </span>
    <span class="parameter-name">
     cancelOnError
    </span>
   </span>
   )
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Creates a
   <a class="" href="dart-async/StreamTransformer-class.html">
    StreamTransformer
   </a>
   .
  </p>
  <p>
   The returned instance takes responsibility of implementing (
   <a class="" href="dart-async/StreamTransformer/bind.html">
    bind
   </a>
   ).
When the user invokes
   <code>
    bind
   </code>
   it returns a new &#34;bound&#34; stream. Only when
the user starts listening to the bound stream, the
   <code>
    listen
   </code>
   method
invokes the given closure
   <code>
    transformer
   </code>
   .
  </p>
  <p>
   The
   <code>
    transformer
   </code>
   closure receives the stream, that was bound, as argument
and returns a
   <a class="" href="dart-async/StreamSubscription-class.html">
    StreamSubscription
   </a>
   . In almost all cases the closure
listens itself to the stream that is given as argument.
  </p>
  <p>
   The result of invoking the
   <code>
    transformer
   </code>
   closure is a
   <a class="" href="dart-async/StreamSubscription-class.html">
    StreamSubscription
   </a>
   .
The bound stream-transformer (created by the
   <code>
    bind
   </code>
   method above) then sets
the handlers it received as part of the
   <code>
    listen
   </code>
   call.
  </p>
  <p>
   Conceptually this can be summarized as follows:
  </p>
  <ol>
   <li>
    <p>
     <code>
      var transformer = new StreamTransformer(transformerClosure);
     </code>
     creates a
     <code>
      StreamTransformer
     </code>
     that supports the
     <code>
      bind
     </code>
     method.
    </p>
   </li>
   <li>
    <p>
     <code>
      var boundStream = stream.transform(transformer);
     </code>
     binds the
     <code>
      stream
     </code>
     and returns a bound stream that has a pointer to
     <code>
      stream
     </code>
     .
    </p>
   </li>
   <li>
    <p>
     <code>
      boundStream.listen(f1, onError: f2, onDone: f3, cancelOnError: b)
     </code>
     starts the listening and transformation. This is accomplished
  in 2 steps: first the
     <code>
      boundStream
     </code>
     invokes the
     <code>
      transformerClosure
     </code>
     with
  the
     <code>
      stream
     </code>
     it captured:
     <code>
      transformerClosure(stream, b)
     </code>
     .
  The result
     <code>
      subscription
     </code>
     , a
     <a class="" href="dart-async/StreamSubscription-class.html">
      StreamSubscription
     </a>
     , is then
  updated to receive its handlers:
     <code>
      subscription.onData(f1)
     </code>
     ,
     <code>
      subscription.onError(f2)
     </code>
     ,
     <code>
      subscription(f3)
     </code>
     . Finally the subscription
  is returned as result of the
     <code>
      listen
     </code>
     call.
    </p>
   </li>
  </ol>
  <p>
   There are two common ways to create a StreamSubscription:
  </p>
  <ol>
   <li>
    <p>
     by creating a new class that implements
     <a class="" href="dart-async/StreamSubscription-class.html">
      StreamSubscription
     </a>
     .
   Note that the subscription should run callbacks in the
     <a class="" href="dart-async/Zone-class.html">
      Zone
     </a>
     the
   stream was listened to.
    </p>
   </li>
   <li>
    <p>
     by allocating a
     <a class="" href="dart-async/StreamController-class.html">
      StreamController
     </a>
     and to return the result of
   listening to its stream.
    </p>
   </li>
  </ol>
  <p>
   Example use of a duplicating transformer:
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    stringStream.transform(new StreamTransformer&lt;String, String&gt;(
    (Stream&lt;String&gt; input, bool cancelOnError) {
      StreamController&lt;String&gt; controller;
      StreamSubscription&lt;String&gt; subscription;
      controller = new StreamController&lt;String&gt;(
        onListen: () {
          subscription = input.listen((data) {
              // Duplicate the data.
              controller.add(data);
              controller.add(data);
            },
            onError: controller.addError,
            onDone: controller.close,
            cancelOnError: cancelOnError);
        },
        onPause: subscription.pause,
        onResume: subscription.resume,
        onCancel: subscription.cancel,
        sync: true);
      return controller.stream.listen(null);
    });
   </code>
  </pre>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    const factory StreamTransformer(
    StreamSubscription&lt;T&gt; transformer(Stream&lt;S&gt; stream, bool cancelOnError))
    = _StreamSubscriptionTransformer;
   </code>
  </pre>
 </section>
</div>
