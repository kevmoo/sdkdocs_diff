<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   void
  </span>
  <span class="name ">
   scheduleMicrotask
  </span>
  (
  <wbr>
  <span class="parameter" id="scheduleMicrotask-param-callback">
   <span class="type-annotation">
    void
   </span>
   <span class="parameter-name">
    callback
   </span>
   ()
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Runs a function asynchronously.
  </p>
  <p>
   Callbacks registered through this function are always executed in order and
are guaranteed to run before other asynchronous events (like
   <a class="" href="dart-async/Timer-class.html">
    Timer
   </a>
   events,
or DOM events).
  </p>
  <p>
   <strong>
    Warning:
   </strong>
   it is possible to starve the DOM by registering asynchronous
callbacks through this method. For example the following program runs
the callbacks without ever giving the Timer callback a chance to execute:
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    main() {
  Timer.run(() { print(&#34;executed&#34;); });  // Will never be executed.
  foo() {
    scheduleMicrotask(foo);  // Schedules [foo] in front of other events.
  }
  foo();
}
   </code>
  </pre>
  <h2>
   Other resources
  </h2>
  <ul>
   <li>
    <p>
     <a href="https://www.dartlang.org/articles/event-loop/">
      The Event Loop and Dart
     </a>
     :
Learn how Dart handles the event queue and microtask queue, so you can write
better asynchronous code with fewer surprises.
    </p>
   </li>
  </ul>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    void scheduleMicrotask(void callback()) {
  _Zone currentZone = Zone.current;
  if (identical(_ROOT_ZONE, currentZone)) {
    // No need to bind the callback. We know that the root&#39;s scheduleMicrotask
    // will be invoked in the root zone.
    _rootScheduleMicrotask(null, null, _ROOT_ZONE, callback);
    return;
  }
  _ZoneFunction implementation = currentZone._scheduleMicrotask;
  if (identical(_ROOT_ZONE, implementation.zone) &amp;&amp;
      _ROOT_ZONE.inSameErrorZone(currentZone)) {
    _rootScheduleMicrotask(null, null, currentZone,
                           currentZone.registerCallback(callback));
    return;
  }
  Zone.current.scheduleMicrotask(
      Zone.current.bindCallback(callback, runGuarded: true));
}
   </code>
  </pre>
 </section>
</div>
