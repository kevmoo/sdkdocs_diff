<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="name ">
   Completer.sync
  </span>
  (
  <wbr>
  )
 </section>
 <section class="desc markdown">
  <p>
   Completes the future synchronously.
  </p>
  <p>
   This constructor should be avoided unless the completion of the future is
known to be the final result of another asynchronous operation. If in doubt
use the default
   <a class="" href="dart-async/Completer-class.html">
    Completer
   </a>
   constructor.
  </p>
  <p>
   Using an normal, asynchronous, completer will never give the wrong
behavior, but using a synchronous completer incorrectly can cause
otherwise correct programs to break.
  </p>
  <p>
   A synchronous completer is only intended for optimizing event
propagation when one asynchronous event immediately triggers another.
It should not be used unless the calls to
   <a class="" href="dart-async/Completer/complete.html">
    complete
   </a>
   and
   <a class="" href="dart-async/Completer/completeError.html">
    completeError
   </a>
   are guaranteed to occur in places where it won&#39;t break
   <code>
    Future
   </code>
   invariants.
  </p>
  <p>
   Completing synchronously means that the completer&#39;s future will be
completed immediately when calling the
   <a class="" href="dart-async/Completer/complete.html">
    complete
   </a>
   or
   <a class="" href="dart-async/Completer/completeError.html">
    completeError
   </a>
   method on a synchronous completer, which also calls any callbacks
registered on that future.
  </p>
  <p>
   Completing synchronously must not break the rule that when you add a
callback on a future, that callback must not be called until the code
that added the callback has completed.
For that reason, a synchronous completion must only occur at the very end
(in &#34;tail position&#34;) of another synchronous event,
because at that point, completing the future immediately is be equivalent
to returning to the event loop and completing the future in the next
microtask.
  </p>
  <p>
   Example:
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    var completer = new Completer.sync();
// The completion is the result of the asynchronous onDone event.
// No other operation is performed after the completion. It is safe
// to use the Completer.sync constructor.
stream.listen(print, onDone: () { completer.complete(&#34;done&#34;); });
   </code>
  </pre>
  <p>
   Bad example. Do not use this code. Only for illustrative purposes:
  </p>
  <pre class="prettyprint lang-dart">
   <code>
    var completer = new Completer.sync();
completer.future.then((_) { bar(); });
// The completion is the result of the asynchronous onDone event.
// However, there is still code executed after the completion. This
// operation is *not* safe.
stream.listen(print, onDone: () {
  completer.complete(&#34;done&#34;);
  foo();  // In this case, foo() runs after bar().
});
   </code>
  </pre>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    factory Completer.sync() =&gt; new _SyncCompleter&lt;T&gt;();
   </code>
  </pre>
 </section>
</div>
