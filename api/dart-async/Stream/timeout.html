<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
  </span>
  <span class="name ">
   timeout
  </span>
  (
  <wbr>
  <span class="parameter" id="timeout-param-timeLimit">
   <span class="type-annotation">
    <a class="" href="dart-core/Duration-class.html">
     Duration
    </a>
   </span>
   <span class="parameter-name">
    timeLimit
   </span>
  </span>
  , {
  <span class="parameter" id="timeout-param-onTimeout">
   <span class="type-annotation">
    void
   </span>
   <span class="parameter-name">
    onTimeout
   </span>
   (
   <span class="parameter" id="onTimeout-param-sink">
    <span class="parameter-name">
     sink
    </span>
   </span>
   )
  </span>
  })
 </section>
 <section class="desc markdown">
  <p>
   Creates a new stream with the same events as this stream.
  </p>
  <p>
   Whenever more than
   <code>
    timeLimit
   </code>
   passes between two events from this stream,
the
   <code>
    onTimeout
   </code>
   function is called.
  </p>
  <p>
   The countdown doesn&#39;t start until the returned stream is listened to.
The countdown is reset every time an event is forwarded from this stream,
or when the stream is paused and resumed.
  </p>
  <p>
   The
   <code>
    onTimeout
   </code>
   function is called with one argument: an
   <a class="" href="dart-async/EventSink-class.html">
    EventSink
   </a>
   that allows putting events into the returned stream.
This
   <code>
    EventSink
   </code>
   is only valid during the call to
   <code>
    onTimeout
   </code>
   .
  </p>
  <p>
   If
   <code>
    onTimeout
   </code>
   is omitted, a timeout will just put a
   <a class="" href="dart-async/TimeoutException-class.html">
    TimeoutException
   </a>
   into the error channel of the returned stream.
  </p>
  <p>
   The returned stream is a broadcast stream if this stream is.
If a broadcast stream is listened to more than once, each subscription
will have its individually timer that starts counting on listen,
and the subscriptions&#39; timers can be paused individually.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    Stream timeout(Duration timeLimit, {void onTimeout(EventSink sink)}) {
  StreamController controller;
  // The following variables are set on listen.
  StreamSubscription&lt;T&gt; subscription;
  Timer timer;
  Zone zone;
  Function timeout;

  void onData(T event) {
    timer.cancel();
    controller.add(event);
    timer = zone.createTimer(timeLimit, timeout);
  }
  void onError(error, StackTrace stackTrace) {
    timer.cancel();
    assert(controller is _StreamController ||
           controller is _BroadcastStreamController);
    var eventSink = controller;
    eventSink._addError(error, stackTrace);  // Avoid Zone error replacement.
    timer = zone.createTimer(timeLimit, timeout);
  }
  void onDone() {
    timer.cancel();
    controller.close();
  }
  void onListen() {
    // This is the onListen callback for of controller.
    // It runs in the same zone that the subscription was created in.
    // Use that zone for creating timers and running the onTimeout
    // callback.
    zone = Zone.current;
    if (onTimeout == null) {
      timeout = () {
        controller.addError(new TimeoutException(&#34;No stream event&#34;,
                                                 timeLimit), null);
      };
    } else {
      onTimeout = zone.registerUnaryCallback(onTimeout);
      _ControllerEventSinkWrapper wrapper =
          new _ControllerEventSinkWrapper(null);
      timeout = () {
        wrapper._sink = controller;  // Only valid during call.
        zone.runUnaryGuarded(onTimeout, wrapper);
        wrapper._sink = null;
      };
    }

    subscription = this.listen(onData, onError: onError, onDone: onDone);
    timer = zone.createTimer(timeLimit, timeout);
  }
  Future onCancel() {
    timer.cancel();
    Future result = subscription.cancel();
    subscription = null;
    return result;
  }
  controller = isBroadcast
      ? new _SyncBroadcastStreamController(onListen, onCancel)
      : new _SyncStreamController(
            onListen,
            () {
              // Don&#39;t null the timer, onCancel may call cancel again.
              timer.cancel();
              subscription.pause();
            },
            () {
              subscription.resume();
              timer = zone.createTimer(timeLimit, timeout);
            },
            onCancel);
  return controller.stream;
}
   </code>
  </pre>
 </section>
</div>
