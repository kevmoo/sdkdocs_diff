<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   &lt;
   <a class="" href="dart-core/String-class.html">
    String
   </a>
   &gt;
  </span>
  <span class="name ">
   join
  </span>
  (
  <wbr>
  [
  <span class="parameter" id="join-param-separator">
   <span class="type-annotation">
    <a class="" href="dart-core/String-class.html">
     String
    </a>
   </span>
   <span class="parameter-name">
    separator
   </span>
   =
   <span class="default-value">
    &#34;&#34;
   </span>
  </span>
  ])
 </section>
 <section class="desc markdown">
  <p>
   Collects string of data events&#39; string representations.
  </p>
  <p>
   If
   <code>
    separator
   </code>
   is provided, it is inserted between any two
elements.
  </p>
  <p>
   Any error in the stream causes the future to complete with that
error. Otherwise it completes with the collected string when
the &#34;done&#34; event arrives.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    Future&lt;String&gt; join([String separator = &#34;&#34;]) {
  _Future&lt;String&gt; result = new _Future&lt;String&gt;();
  StringBuffer buffer = new StringBuffer();
  StreamSubscription subscription;
  bool first = true;
  subscription = this.listen(
    (T element) {
      if (!first) {
        buffer.write(separator);
      }
      first = false;
      try {
        buffer.write(element);
      } catch (e, s) {
        _cancelAndErrorWithReplacement(subscription, result, e, s);
      }
    },
    onError: (e) {
      result._completeError(e);
    },
    onDone: () {
      result._complete(buffer.toString());
    },
    cancelOnError: true);
  return result;
}
   </code>
  </pre>
 </section>
</div>
