<div class="col-xs-12 col-sm-9 col-md-8 main-content">
 <section class="multi-line-signature">
  <span class="returntype">
  </span>
  <span class="name ">
   doWhile
  </span>
  (
  <wbr>
  <span class="parameter" id="doWhile-param-f">
   <span class="type-annotation">
    dynamic
   </span>
   <span class="parameter-name">
    f
   </span>
   ()
  </span>
  )
 </section>
 <section class="desc markdown">
  <p>
   Perform an async operation repeatedly until it returns
   <code>
    false
   </code>
   .
  </p>
  <p>
   Runs
   <code>
    f
   </code>
   repeatedly, starting the next iteration only when the
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   returned by
   <code>
    f
   </code>
   completes to
   <code>
    true
   </code>
   . Returns a
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   that completes once
   <code>
    f
   </code>
   returns
   <code>
    false
   </code>
   .
  </p>
  <p>
   The return values of all
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   s are discarded. Any errors will cause the
iteration to stop and will be piped through the returned
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   .
  </p>
  <p>
   The function
   <code>
    f
   </code>
   may return either a
   <a class="" href="dart-core/bool-class.html">
    bool
   </a>
   or a
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   that completes to
a
   <a class="" href="dart-core/bool-class.html">
    bool
   </a>
   . If it returns a non-
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   , iteration continues immediately.
Otherwise it waits for the returned
   <a class="" href="dart-async/Future-class.html">
    Future
   </a>
   to complete.
  </p>
 </section>
 <section class="summary source-code" id="source">
  <h2>
   <span>
    Source
   </span>
  </h2>
  <pre>
   <code class="prettyprint lang-dart">
    static Future doWhile(f()) {
  _Future doneSignal = new _Future();
  var nextIteration;
  // Bind this callback explicitly so that each iteration isn&#39;t bound in the
  // context of all the previous iterations&#39; callbacks.
  nextIteration = Zone.current.bindUnaryCallback((bool keepGoing) {
    if (keepGoing) {
      new Future.sync(f).then(nextIteration,
                              onError: doneSignal._completeError);
    } else {
      doneSignal._complete(null);
    }
  }, runGuarded: true);
  nextIteration(true);
  return doneSignal;
}
   </code>
  </pre>
 </section>
</div>
